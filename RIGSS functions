###########################################
#CREATE RULES FUNCTIONS
#The sub-elements that can be used to make up the rules
vars <- c("A", "B", "C", "D", "E", "F", "G") #These are the variables from the agent based model
#For the meaning of each, see lab notes 16.10.23
operators <- c("+", "-" , "/", "*","|", "&")
equals <- c("==", ">", "<", "!=", "<=", ">=")

# Define a basic structure for a binary tree node
node <- function(value, left = NULL, right = NULL) {
  return(list(value = value, left = left, right = right))
}

# Function to create a random binary tree with the specified depth
create_random_binary_tree <- function(max_depth) {
  if (max_depth == 0 || runif(1) < 0.2) {
    return(node(sample(vars, 1)))  # Return a leaf node (value less than 10)
  }
  value <- sample(operators, 1)  # Generate a value >= 10
  left_subtree <- create_random_binary_tree(max_depth - 1)
  right_subtree <- create_random_binary_tree(max_depth - 1)
  return(node(value, left_subtree, right_subtree))
}

# Function to perform an inorder traversal and print the tree with brackets around pairs of leaf nodes and their parent
inorder_traversal <- function(root) {
  if (!is.null(root)) {
    if (!is.null(root$left) && is.null(root$left$left) && is.null(root$left$right) &&
        !is.null(root$right) && is.null(root$right$left) && is.null(root$right$right)) {
      cat("(", root$left$value, " ", root$value, " ", root$right$value, ") ")
    } else {
      inorder_traversal(root$left)
      cat(root$value, " ")
      inorder_traversal(root$right)
    }
  }
}

#function to create the initial population of rules
createRules <- function(n){
rules <- list()
for (i in 1:n){
random_tree <- create_random_binary_tree(sample(1:4,1))
random_tree[1] <- sample(equals, 1)
rules[[i]] <- random_tree
}
return(rules)
}

#mutation function
change_node_value_conditional <- function(tree) {
  stack <- list(tree)
  
  while (length(stack) > 0) {
    current_node <- stack[[length(stack)]]
    stack <- stack[-length(stack)]
    
    if (is.leaf(current_node)) {
      # Perform the operation for leaf nodes here
    # If it's a leaf node, apply the condition and set the new value
    if (any(vars == tree$value)){
      tree$value <- sample(vars,1)
    } else if (any(operators == tree$value)) {
      tree$value <- sample(operators,1)
    } else if (any(equals == tree$value)) {
      tree$value <- sample(equals,1)
    }
    } else {
      # Randomly select whether to go left or right
      go_left <- sample(c(TRUE, FALSE), 1)
      
      if (go_left) {
        stack <- c(stack, current_node$left)
      } else {
        stack <- c(stack, current_node$right)
      }
    }
  }
}

# Function to print a binary tree visually, each node printed only once
print_binary_tree <- function(node, level = 0, visited_nodes = c()) {
  if (!is.null(node) && !(node$value %in% visited_nodes)) {
    cat(paste(rep("  ", level), node$value, "\n"))
    visited_nodes <- c(visited_nodes, node$value)
    visited_nodes <- print_binary_tree(node$left, level + 1, visited_nodes)
    visited_nodes <- print_binary_tree(node$right, level + 1, visited_nodes)
  }
  return(visited_nodes)
}