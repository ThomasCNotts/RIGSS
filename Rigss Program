#################################################
#EVOLVE RULES

#create first population of rules
pop <- 10

rules <- createRules(pop)

thenTake <- c()
for (i in 1:pop){
thenTake[i] <- sample(0:10,1) #the value after then for each rule
}

#start generation loop to create each population generation - what is the stopping condition?

#start rules loop to test each rule

for (i in 1:length(rules)){

#agentCommand <- getStringRule(rules[[i]])
#agentCommand <- cat("if (", agentCommand, ") {", thenTake[i], "}")

#eval(parse(text = rule))

#run ABM here for one rule here

#test for fitness

#end us with a vector of fitnesses called fitness
#use dist()

}

#################################################

#genetic operations here to build up a new population

tempRules <- list() #this will hold the new generation of rules
counter <- 0

for (i in 1:length(rules)){ #this is to create the next generation of pop size rules - it will end up bigger as crossover creates two rules

#choose an operation - reproduction, mutation, crossover
choice <- sample(c("reproduction", "mutation", "crossover"), 1)

if (choice == "reproduction"){
tempRules[[counter]] <- sample(rules[[1]], 1)   #      , prob=fitness) #choose a rule with probabilty proportional to fitness
} else if (choice == "mutation"){
chosenRule <- rules[[sample(1:length(rules),1)]]     #    , prob=fitness)
#this is point mutation but many others exist
#to use:
#unlist rule
y <- unlist(chosenRule[[1]])
#choose something to mutate, r for replace (rv is replacement value)
r <- sample(y,1)[[1]]

#figure out type of r
if (any(vars == r)) {rv <- sample(vars,1)
} else if (any(operators == r)) {rv <- sample(operators,1)
} else {
rv <- sample(equals,1)
}

m <- list()
tempRules[[counter]] <- mutate(root = chosenRule, toReplace = r, replaceValue = rv)

} else if (choice == "crossover"){

rule1 <- rules[[sample(1:length(rules),1)]]     #    , prob=fitness)
rule2 <- rules[[sample(1:length(rules),1)]]     #    , prob=fitness)

r1String <- getStringRule(rule1)
r2String <- getStringRule(rule2)

if (any(operators %in% unlist(strsplit(r1String, ""))) & any(operators %in% unlist(strsplit(r2String, "")))) {
op1 <- sample(operators[operators %in% unlist(strsplit(r1String, ""))],1)
op2 <- sample(operators[operators %in% unlist(strsplit(r2String, ""))],1)

subtrees1 <- find_paths_to_nodes(rule1, op1)
subtrees2 <- find_paths_to_nodes(rule2, op2)

subtree1Path <- subtrees1[[sample(1:length(subtrees1),1)]]
subtree2Path <- subtrees2[[sample(1:length(subtrees2),1)]]

co1 <- get_subtree(rule1,subtree1Path)
co2 <- get_subtree(rule2,subtree2Path)

newRule1 <- replace_subtree(rule1, subtree1Path, co2)
tempRules[[counter] <- newRule1
counter <- counter + 1

newRule2 <- replace_subtree(rule2, subtree2Path, co1)
tempRules[[counter] <- newRule2
}#end of if any...

}#end of crossover

counter <- counter + 1

}

rules <- tempRules









